{0:tutorial Tutorial}

{1:started Getting started}

With [Cmdliner] your program's [main] function evaluates a term. A {e
term} is a value of type {!Cmdliner.Term.t}. The type parameter
indicates the type of the result of the evaluation.

One way to create terms is by lifting regular OCaml values with
{!Cmdliner.Term.const}. Terms can be applied to terms evaluating to
functional values with {!Cmdliner.Term.($)}. For example for the
function:

{[
let revolt () = print_endline "Revolt!"
]}

the term :

{[
open Cmdliner

let revolt_t = Term.(const revolt $ const ())
]}

is a term that evaluates to the result (and effect) of the [revolt]
function. Terms are evaluated with {!Cmdliner.Term.eval}:

{[
let () = Term.exit @@ Term.eval (revolt_t, Term.info "revolt")
]}

This defines a command line program named ["revolt"], without command
line arguments, that just prints ["Revolt!"] on [stdout].

{[
> ./revolt
Revolt!
]}

The combinators in the {!Cmdliner.Arg} module allow to extract command
line arguments as terms. These terms can then be applied to lifted
OCaml functions to be evaluated by the program.

Terms corresponding to command line argument data that are part of a
term evaluation implicitly define a command line syntax.  We show this
on an concrete example.

Consider the [chorus] function that prints repeatedly a given message :

{[
let chorus count msg = for i = 1 to count do print_endline msg done
]}

we want to make it available from the command line with the synopsis:

{[
chorus [-c COUNT | --count=COUNT] [MSG]
]}

where [COUNT] defaults to [10] and [MSG] defaults to ["Revolt!"]. We
first define a term corresponding to the [--count] option:

{[
let count =
  let doc = "Repeat the message $(docv) times." in
  Arg.(value & opt int 10 & info ["c"; "count"] ~docv:"COUNT" ~doc)
]}

This says that [count] is a term that evaluates to the value of an
optional argument of type [int] that defaults to [10] if unspecified
and whose option name is either [-c] or [--count]. The arguments [doc]
and [docv] are used to generate the option's man page information.

The term for the positional argument [MSG] is:

{[
let msg =
  let doc = "Overrides the default message to print." in
  let env = Arg.env_var "CHORUS_MSG" ~doc in
  let doc = "The message to print." in
  Arg.(value & pos 0 string "Revolt!" & info [] ~env ~docv:"MSG" ~doc)
]}

which says that [msg] is a term whose value is the positional argument
at index [0] of type [string] and defaults to ["Revolt!"]  or the
value of the environment variable [CHORUS_MSG] if the argument is
unspecified on the command line. Here again [doc] and [docv] are used
for the man page information.

The term for executing [chorus] with these command line arguments is :

{[
let chorus_t = Term.(const chorus $ count $ msg)
]}

We are now ready to define our main function:

{[
let info =
  let doc = "print a customizable message repeatedly" in
  let man = [
    `S Manpage.s_bugs;
    `P "Email bug reports to <hehey at example.org>." ]
  in
  Term.info "chorus" ~version:"%â€Œ%VERSION%%" ~doc ~exits:Term.default_exits ~man

let main () = Term.exit @@ Term.eval (chorus_t, info)
let () = main ()
]}

The [info] value created with {!Cmdliner.Term.val-info} gives more
information about the term we execute and is used to generate the
program's man page. Since we provided a [~version] string, the program
will automatically respond to the [--version] option by printing this
string.

A program using {!Cmdliner.Term.eval} always responds to the [--help] option by
showing the man page about the program generated using the information
you provided with {!Cmdliner.Term.val-info} and {!Cmdliner.Arg.val-info}.
Here is the output generated by our example :

{v
> ./chorus --help
NAME
       chorus - print a customizable message repeatedly

SYNOPSIS
       chorus [OPTION]... [MSG]

ARGUMENTS
       MSG (absent=Revolt! or CHORUS_MSG env)
           The message to print.

OPTIONS
       -c COUNT, --count=COUNT (absent=10)
           Repeat the message COUNT times.

       --help[=FMT] (default=auto)
           Show this help in format FMT. The value FMT must be one of auto,
           pager, groff or plain. With auto, the format is pager or
           plain whenever the TERM env var is dumb or undefined.

       --version
           Show version information.

EXIT STATUS
       chorus exits with the following status:

       0   on success.

       124 on command line parsing errors.

       125 on unexpected internal errors (bugs).

ENVIRONMENT
       These environment variables affect the execution of chorus:

       CHORUS_MSG
           Overrides the default message to print.

BUGS
       Email bug reports to <hehey at example.org>.
v}

If a pager is available, this output is written to a pager. This help
is also available in plain text or in the
{{:http://www.gnu.org/software/groff/groff.html}groff} man page format
by invoking the program with the option [--help=plain] or
[--help=groff].

For examples of more complex command line definitions look and run
the {{!page-examples}examples}.

{1:multiterms Multiple terms}

[Cmdliner] also provides support for programs like [darcs] or [git]
that have multiple commands each with their own syntax:

{[prog COMMAND [OPTION]... ARG...]}

A command is defined by coupling a term with {{!Cmdliner.Term.tinfo}term
information}. The term information defines the command name and its
man page. Given a list of commands the function {!Cmdliner.Term.eval_choice}
will execute the term corresponding to the [COMMAND] argument or a
specific "main" term if there is no [COMMAND] argument.

{1:doclang Documentation markup language}

Manpage {{!Cmdliner.Manpage.block}blocks} and doc strings support the
following markup language.

{ul
{- Markup directives [$(i,text)] and [$(b,text)], where [text] is raw
   text respectively rendered in italics and bold.}
{- Outside markup directives, context dependent variables of the form
   [$(var)] are substituted by marked up data. For example in a term's
   man page [$(tname)] is substituted by the term name in bold.}
{- Characters $, (, ) and \ can respectively be escaped by \$, \(, \)
   and \\ (in OCaml strings this will be ["\\$"], ["\\("], ["\\)"],
   ["\\\\"]). Escaping $ and \ is mandatory everywhere. Escaping ) is
   mandatory only in markup directives. Escaping ( is only here for
   your symmetric pleasure. Any other sequence of characters starting
   with a \ is an illegal character sequence.}
{- Refering to unknown markup directives or variables will generate
   errors on standard error during documentation generation.}}

{1:manual Manual}

Man page sections for a term are printed in the order specified by the
term manual as given to {!Cmdliner.Term.val-info}. Unless specified
explicitely in the term's manual the following sections are
automaticaly created and populated for you:

{ul
{- {{!Cmdliner.Manpage.s_name}[NAME]} section.}
{- {{!Cmdliner.Manpage.s_synopsis}[SYNOPSIS]} section.}}

The various [doc] documentation strings specified by the term's
subterms and additional metadata get inserted at the end of the
documentation section name [docs] they respectively mention, in the
following order:

{ol
{- Commands, see {!Cmdliner.Term.val-info}.}
{- Positional arguments, see {!Cmdliner.Arg.type-info}. Those are listed iff
   both the [docv] and [doc] string is specified by {!Cmdliner.Arg.val-info}.}
{- Optional arguments, see {!Cmdliner.Arg.val-info}.}
{- Exit statuses, see {!Cmdliner.Term.val-exit_info}.}
{- Environment variables, see
   {!Cmdliner.Arg.val-env_var} and {!Cmdliner.Term.val-env_info}.}}

If a [docs] section name is mentioned and does not exist in the term's
manual, an empty section is created for it, after which the [doc] strings
are inserted, possibly prefixed by boilerplate text (e.g. for
{!Cmdliner.Manpage.s_environment} and {!Cmdliner.Manpage.s_exit_status}).

If the created section is:
{ul
{- {{!Cmdliner.Manpage.standard_sections}standard}, it
    is inserted at the right place in the order specified
    {{!Cmdliner.Manpage.standard_sections}here}, but after a possible non-standard
    section explicitely specified by the term since the latter get the
    order number of the last previously specified standard section
    or the order of {!Cmdliner.Manpage.s_synopsis} if there is no such section.}
{-  non-standard, it is inserted before the {!Cmdliner.Manpage.s_commands}
    section or the first subsequent existing standard section if it
    doesn't exist. Taking advantage of this behaviour is discouraged,
    you should declare manually your non standard section in the term's
    manual.}}
